<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FONTLAB 8</title>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght,SOFT,WONK@9..144,100..900,0..100,0..1&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary: #00f5ff;
      --secondary: #ff00d0;
      --accent: #7d4cff;
      --vibrant1: #ff9500;
      --vibrant2: #00d0ff;
      --vibrant3: #ff3ee7;
      --light: #ffffff;
    }
    body {
      font-family: 'Fraunces', serif;
      background: linear-gradient(135deg, #2b3aff, #832bff, #ff2bd4);
      color: var(--light);
      overflow-x: hidden;
      min-height: 100vh;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    .content {
      position: relative;
      z-index: 2;
      max-width: 1200px;
      margin: 0 auto;
      padding: 5vh 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .logo {
      font-size: clamp(2rem, 3vw, 2.5rem);
      font-variation-settings: 'wght' 900, 'opsz' 144, 'WONK' 1;
      background: linear-gradient(45deg, var(--vibrant2), var(--vibrant3));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: 8vh;
      text-shadow: 0 0 20px rgba(0, 208, 255, 0.4);
      text-transform: uppercase;
    }
    .title-container {
      text-align: center;
      margin-bottom: 8vh;
      perspective: 1500px;
    }
    .title-line {
      font-size: clamp(4.5rem, 12vw, 8.5rem);
      line-height: 1.2;
      opacity: 0;
      transform: translateY(40px) rotateX(-10deg);
      animation: fadeUp 1s forwards;
      white-space: nowrap;
    }
    .title-line:nth-child(2) {
      animation-delay: 0.3s;
    }
    .word {
      display: inline-block;
      position: relative;
      margin: 0 -0.03em;
      transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    .word.smart, .word.variable {
      color: var(--light);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    .word.color {
      background: linear-gradient(90deg, #ff9500, #00d0ff, #d400ff, #ff5e3a);
      background-size: 300% 100%;
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
      animation: gradientShift 8s infinite alternate ease-in-out;
    }
    .word.fonts {
      color: var(--light);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    .description {
      font-size: clamp(1.3rem, 2.2vw, 1.5rem);
      font-variation-settings: 'wght' 500, 'opsz' 50;
      max-width: 800px;
      text-align: center;
      margin-bottom: 8vh;
      opacity: 0;
      animation: fadeUp 1s forwards 0.6s;
    }
    .cta {
      display: inline-block;
      background: linear-gradient(135deg, #ff9500, #ff3ee7);
      color: var(--light);
      border: none;
      padding: 18px 50px;
      border-radius: 50px;
      font-variation-settings: 'wght' 700, 'opsz' 80;
      font-size: 1.3rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      opacity: 0;
      animation: fadeUp 1s forwards 0.9s;
      text-decoration: none;
      transition: all 0.4s ease;
    }
    .cta:hover {
      transform: translateY(-5px) scale(1.05);
      box-shadow: 0 15px 30px rgba(255, 62, 231, 0.3);
      font-variation-settings: 'wght' 900, 'opsz' 100;
    }
    .cta::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.6s ease;
      z-index: -1;
    }
    .cta:hover::before {
      width: 300px;
      height: 300px;
    }
    @keyframes fadeUp {
      to {
        opacity: 1;
        transform: translateY(0) rotateX(0);
      }
    }
    @keyframes gradientShift {
      0% {
        background-position: 0% 50%;
      }
      100% {
        background-position: 100% 50%;
      }
    }
    @media (max-width: 768px) {
      .content {
        padding: 4vh 15px;
      }
      .logo {
        margin-bottom: 6vh;
      }
      .title-container {
        margin-bottom: 6vh;
      }
      .description {
        margin-bottom: 6vh;
      }
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>
  <div class="content">
    <h3 class="logo">FontLab 8</h3>
    <div class="title-container">
      <h1 class="title-line">
        <span class="word smart">Smart.</span><span class="word variable">Variable.</span>
      </h1>
      <h1 class="title-line">
        <span class="word color">Color.</span><span class="word fonts">Fonts.</span>
      </h1>
    </div>
    <p class="description">Craft interstellar variable fonts with infinite dimensions. Design, refine, and launch professional typography for any universe.</p>
    <a href="https://www.fontlab.com/font-editor/fontlab/" class="cta">Learn More</a>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('bgCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // Background gradient animation
    function animateBackground() {
      const time = Date.now() * 0.0002;
      document.body.style.background = `linear-gradient(${time * 30}deg, #2b3aff, #832bff, #ff2bd4, #ff9500)`;
      requestAnimationFrame(animateBackground);
    }
    animateBackground();
    
    // Font nodes that will form connections
    class Node {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 3 + 1;
        this.speedX = Math.random() * 0.5 - 0.25;
        this.speedY = Math.random() * 0.5 - 0.25;
        this.color = this.getRandomColor();
      }
      
      getRandomColor() {
        const colors = [
          'rgba(255, 149, 0, 0.7)',   // Orange
          'rgba(0, 208, 255, 0.7)',    // Cyan
          'rgba(255, 62, 231, 0.7)',   // Pink
          'rgba(255, 255, 255, 0.7)'   // White
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }
      
      update() {
        // Move nodes
        this.x += this.speedX;
        this.y += this.speedY;
        
        // Bounce at edges
        if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
        if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
      }
      
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }
    
    // Create nodes
    const nodeCount = Math.min(Math.floor(window.innerWidth * window.innerHeight / 15000), 100);
    const nodes = [];
    
    for (let i = 0; i < nodeCount; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      nodes.push(new Node(x, y));
    }
    
    // Mouse interaction
    let mouse = {
      x: undefined,
      y: undefined,
      radius: 150
    };
    
    window.addEventListener('mousemove', (e) => {
      mouse.x = e.x;
      mouse.y = e.y;
    });
    
    window.addEventListener('touchmove', (e) => {
      if (e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
      }
    });
    
    window.addEventListener('mouseout', () => {
      mouse.x = undefined;
      mouse.y = undefined;
    });
    
    // Typography animation with smooth transitions
    const words = document.querySelectorAll('.word');
    
    // Initial variations
    const variations = {
      smart: { wght: 600, opsz: 120, soft: 30, wonk: 0.5 },
      variable: { wght: 300, opsz: 60, soft: 80, wonk: 0.8 },
      color: { wght: 600, opsz: 100, soft: 50, wonk: 0.3 },
      fonts: { wght: 800, opsz: 144, soft: 20, wonk: 0.7 }
    };
    
    // Target variations for hover
    const targetVariations = {
      smart: { wght: 800, opsz: 144, soft: 20, wonk: 1 },
      variable: { wght: 200, opsz: 40, soft: 90, wonk: 0.8 },
      color: { wght: 600, opsz: 100, soft: 50, wonk: 0.3 },
      fonts: { wght: 900, opsz: 144, soft: 30, wonk: 0.5 }
    };
    
    // Apply initial variations
    words.forEach(word => {
      const classList = Array.from(word.classList);
      let type;
      
      if (classList.includes('smart')) type = 'smart';
      else if (classList.includes('variable')) type = 'variable';
      else if (classList.includes('color')) type = 'color';
      else if (classList.includes('fonts')) type = 'fonts';
      
      if (type) {
        const variation = variations[type];
        word.style.fontVariationSettings = `'wght' ${variation.wght}, 'opsz' ${variation.opsz}, 'SOFT' ${variation.soft}, 'WONK' ${variation.wonk}`;
      }
    });
    
    // Smooth animation helpers
    function lerp(start, end, t) {
      return start * (1 - t) + end * t;
    }
    
    function animateVariation(word, startVar, targetVar, progress) {
      const wght = lerp(startVar.wght, targetVar.wght, progress);
      const opsz = lerp(startVar.opsz, targetVar.opsz, progress);
      const soft = lerp(startVar.soft, targetVar.soft, progress);
      const wonk = lerp(startVar.wonk, targetVar.wonk, progress);
      
      word.style.fontVariationSettings = `'wght' ${Math.round(wght)}, 'opsz' ${Math.round(opsz)}, 'SOFT' ${Math.round(soft)}, 'WONK' ${wonk.toFixed(2)}`;
    }
    
    // Track animation state for each word
    const animationState = {
      smart: { animating: false, startTime: 0, duration: 800, hovering: false },
      variable: { animating: false, startTime: 0, duration: 800, hovering: false },
      color: { animating: false, startTime: 0, duration: 800, hovering: false },
      fonts: { animating: false, startTime: 0, duration: 800, hovering: false }
    };
    
    words.forEach(word => {
      const classList = Array.from(word.classList);
      let type;
      
      if (classList.includes('smart')) type = 'smart';
      else if (classList.includes('variable')) type = 'variable';
      else if (classList.includes('color')) type = 'color';
      else if (classList.includes('fonts')) type = 'fonts';
      
      if (type) {
        word.addEventListener('mouseenter', () => {
          animationState[type].hovering = true;
          animationState[type].startTime = Date.now();
          animationState[type].animating = true;
        });
        
        word.addEventListener('mouseleave', () => {
          animationState[type].hovering = false;
          animationState[type].startTime = Date.now();
          animationState[type].animating = true;
        });
      }
    });
    
    // Update animations
    function updateAnimations() {
      Object.keys(animationState).forEach(type => {
        const state = animationState[type];
        if (state.animating) {
          const word = document.querySelector(`.word.${type}`);
          const elapsed = Date.now() - state.startTime;
          let progress = elapsed / state.duration;
          
          if (progress >= 1) {
            progress = 1;
            state.animating = false;
          }
          
          // Easing function
          progress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
          
          if (state.hovering) {
            animateVariation(word, variations[type], targetVariations[type], progress);
          } else {
            animateVariation(word, targetVariations[type], variations[type], progress);
          }
        }
      });
      
      requestAnimationFrame(updateAnimations);
    }
    
    updateAnimations();
    
    // Animate color word continuously but smoothly
    const colorWord = document.querySelector('.word.color');
    let lastColorTime = Date.now();
    const colorVariationBase = variations.color;
    
    function animateColorWord() {
      const time = Date.now() / 1000;
      
      // Only animate if not being hovered
      if (!animationState.color.hovering && !animationState.color.animating) {
        const wght = colorVariationBase.wght + Math.sin(time * 0.5) * 200;
        const opsz = colorVariationBase.opsz + Math.cos(time * 0.4) * 30;
        const soft = colorVariationBase.soft + Math.sin(time * 0.7) * 30;
        const wonk = colorVariationBase.wonk + (Math.sin(time * 0.3) * 0.3);
        
        colorWord.style.fontVariationSettings = `'wght' ${Math.round(wght)}, 'opsz' ${Math.round(opsz)}, 'SOFT' ${Math.round(soft)}, 'WONK' ${wonk.toFixed(2)}`;
      }
      
      requestAnimationFrame(animateColorWord);
    }
    
    animateColorWord();
    
    // Main animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw nodes
      for (let i = 0; i < nodes.length; i++) {
        nodes[i].update();
        nodes[i].draw();
        
        // Connect nodes with lines if close enough
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[i].x - nodes[j].x;
          const dy = nodes[i].y - nodes[j].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = canvas.width * 0.15;
          
          if (distance < maxDistance) {
            // Set line opacity based on distance
            const opacity = 1 - (distance / maxDistance);
            
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.3})`;
            ctx.lineWidth = 1;
            ctx.moveTo(nodes[i].x, nodes[i].y);
            ctx.lineTo(nodes[j].x, nodes[j].y);
            ctx.stroke();
          }
        }
        
        // Mouse interaction - push nodes away from cursor
        if (mouse.x !== undefined && mouse.y !== undefined) {
          const dx = nodes[i].x - mouse.x;
          const dy = nodes[i].y - mouse.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < mouse.radius) {
            const force = (mouse.radius - distance) / mouse.radius;
            const directionX = dx / distance || 0;
            const directionY = dy / distance || 0;
            
            nodes[i].x += directionX * force * 2;
            nodes[i].y += directionY * force * 2;
          }
        }
      }
      
      // Text glow effect on proximity
      if (mouse.x !== undefined && mouse.y !== undefined) {
        words.forEach(word => {
          const rect = word.getBoundingClientRect();
          const wordCenterX = rect.left + rect.width / 2;
          const wordCenterY = rect.top + rect.height / 2;
          
          const dx = mouse.x - wordCenterX;
          const dy = mouse.y - wordCenterY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 300) {
            const intensity = 1 - (distance / 300);
            word.style.textShadow = `0 0 ${15 * intensity}px rgba(255, 255, 255, 0.8)`;
          } else {
            word.style.textShadow = '0 0 10px rgba(255, 255, 255, 0.3)';
          }
        });
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
    
    // Add particle burst on click
    document.addEventListener('click', (e) => {
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = '4px';
        particle.style.height = '4px';
        particle.style.background = ['#ff9500', '#00d0ff', '#ff3ee7', '#ffffff'][Math.floor(Math.random() * 4)];
        particle.style.borderRadius = '50%';
        particle.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.7)';
        particle.style.left = `${e.clientX}px`;
        particle.style.top = `${e.clientY}px`;
        particle.style.zIndex = '10';
        document.body.appendChild(particle);
        
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        const dx = Math.cos(angle) * speed;
        const dy = Math.sin(angle) * speed;
        
        particle.animate([
          { transform: 'translate(0, 0) scale(1)', opacity: 1 },
          { transform: `translate(${dx * 20}px, ${dy * 20}px) scale(0)`, opacity: 0 }
        ], {
          duration: Math.random() * 1000 + 500,
          easing: 'cubic-bezier(0.1, 0.8, 0.2, 1)'
        }).onfinish = () => particle.remove();
      }
    });
  </script>
</body>
</html>
